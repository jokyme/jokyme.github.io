[{"title":"从零开始学习AngularJS开发(三) 服务","date":"2016-12-05T13:34:00.000Z","path":"AngularJS/AngularJS-3.html","text":"服务概述Angular服务是一组使用依赖注入装载的可替换对象。你可以使用服务在你的应用程序中组织和分享代码。 Angular 服务特点: 延迟加载 - 只有当应用程序组件依赖于某一服务时，Angular才会实例化该服务 单实例 - 每个组件依赖的服务获取到的服务引用，都是从服务工厂创建的单一实例 Angular提供了许多有用的服务(例如 $http), 但是对大多数应用程序而言，我们需要创建自己的服务。 注意：和其他的核心Angular标识符一样，内置服务总是以 $ 符号开头(例如 $http) 使用服务你需要将服务依赖项添加到依赖于该服务的组件中，以此来使用服务。 创建服务我们可以使用Angular Module，通过注册服务名称和服务工厂方法来自由定义我们的服务。 服务工厂方法(service factory function)生成的单一对象或方法会在应用程序余下的生命周期中将服务展现给应用程序。服务会将该对象或方法返回(returned)并注入到任何依赖于该服务的组件中(控制器、服务、过滤器 或 指令) 注册服务服务是通过 Module API 被注册到 modules 中的，我们一般使用 Module factory API 来注册服务: 123456var myModule = angular.module('myModule', []);myModule.factory('serviceId', function() &#123; var shinyNewServiceInstance; // factory function body that constructs shinyNewServiceInstance return shinyNewServiceInstance;&#125;); 注意：该服务实例并不是由你注册的，而是当服务被调用时由工厂服务(factory function)创建的。 依赖服务可以有自己的依赖项。和在控制器中声明依赖项一样，你可以通过在服务的工厂函数签名中指定依赖项的方式来声明服务的依赖项。 以下示例有两个服务，每个服务都有多个依赖项： 12345678910111213141516171819202122232425262728293031323334353637383940var batchModule = angular.module('batchModule', []);/** * The `batchLog` service allows for messages to be queued in memory and flushed * to the console.log every 50 seconds. * * @param &#123;*&#125; message Message to be logged. */batchModule.factory('batchLog', ['$interval', '$log', function($interval, $log) &#123; var messageQueue = []; function log() &#123; if (messageQueue.length) &#123; $log.log('batchLog messages: ', messageQueue); messageQueue = []; &#125; &#125; // start periodic checking $interval(log, 50000); return function(message) &#123; messageQueue.push(message); &#125;&#125;]);/** * `routeTemplateMonitor` monitors each `$route` change and logs the current * template via the `batchLog` service. */batchModule.factory('routeTemplateMonitor', ['$route', 'batchLog', '$rootScope', function($route, batchLog, $rootScope) &#123; return &#123; startMonitoring: function() &#123; $rootScope.$on('$routeChangeSuccess', function() &#123; batchLog($route.current ? $route.current.template : null); &#125;); &#125; &#125;; &#125;]); 在这个示例中,有以下几点需要注意: batchLog 服务依赖于内置的 $interval 和 $log 服务 routeTemplateMonitor 服务依赖于内置的 $route 服务和自定义的 batchLog 服务 两个服务都使用数组标记法声明他们的依赖项 数组中标识符的顺序和 factory 函数中参数名称的顺序一致 使用 $provide 注册服务你可以通过 module 的 config 函数中内置的 $provide 服务来注册服务 1234567angular.module('myModule', []).config(['$provide', function($provide) &#123; $provide.factory('serviceId', function() &#123; var shinyNewServiceInstance; // factory function body that constructs shinyNewServiceInstance return shinyNewServiceInstance; &#125;);&#125;]); 这一技术常被用于在单元测试中模拟出一个服务的依赖项","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://joky.me/tags/AngularJS/"}]},{"title":"从零开始学习AngularJS开发(二) 控制器","date":"2016-12-05T12:55:00.000Z","path":"AngularJS/AngularJS-2.html","text":"控制器的概念Angular 中的控制器通过 controller 方法定义。当我们通过 ng-controller 指令将控制器附加到 DOM 时，Angular会使用规定的控制器构造函数实例化一个控制器对象。同时，会创建一个新的子作用域$scope，并将其作为控制器构造函数的可注入参数。 如果在ng-controller中使用了 controller as [控制器名称] 语法，那么控制器实例将被赋值给[控制器名称] 下列情况使用控制器 设置 $scope 的初始状态 为 $scope 对象添加行为(function) 下列情况不要使用控制器 操作 DOM - 控制器只负责业务逻辑，将页面呈现逻辑添加到控制器中会显著的影响控制器的可测试性。Angular中的数据绑定可以解决绝大多数的DOM操作问题，同时，指令可以封装对DOM的手动操作。 格式化输入 - 使用 Angular 表单控件代替 (angular form controls) 输出结果过滤 - 使用 Angular 过滤器代替 (angular filters) 控制器间共享代码或状态 - 使用 Angular 服务代替 (angular services) 管理其他组件的生命周期(例如：创建服务(service)实例) 设置 $scope 对象的初始状态一般而言，当我们创建一个应用程序时，需要为 $scope 设置初始状态。我们通过给 $scope 对象添加属性的方式来设置 $scope 的初始化状态。在属性里面存在视图模型(会在视图中被呈现的模型)。$scope的所有属性均可以在模板中Controller所注册的DOM节点下被访问。 下面的例子展示了,创建一个 GreetingController，并将一个值为 ‘Hola!’ 的 greeting 属性附加到 $scope 的过程 12345var myApp = angular.module('myApp',[]);myApp.controller('GreetingController', ['$scope', function($scope) &#123; $scope.greeting = 'Hola!';&#125;]); 我们创建了一个 Angular 模块(Angular Module) - myApp. 然后使用.controller()方法将控制器的构造函数添加到模块中. 这将使控制器的构造函数不在全局作用域之内。 这里使用内联注入注解来明确说明控制器中的 $scope 服务依赖项是由Angular提供的。更多信息请查阅依赖注入 我们使用 ng-controller 指令将控制器附加到DOM中. 我们将greeting 属性与模板进行了数据绑定. 123&lt;div ng-controller=\"GreetingController\"&gt; &#123;&#123; greeting &#125;&#125;&lt;/div&gt; 给 Scope 对象添加行为为了在视图中响应事件或执行计算，我们必须为scope添加行为。我们通过将方法附加到 $scope 对象的方式来为scope添加行为。这些方法将会被 模板/视图 调用。下面的示例使用控制器向scope中添加了一个计算一个数的倍数的方法 12345var myApp = angular.module('myApp',[]);myApp.controller('DoubleController', ['$scope', function($scope) &#123; $scope.double = function(value) &#123; return value * 2; &#125;;&#125;]); 当该控制器被附加到DOM中后，double 方法将可以被模板中的Angular表达式调用 123&lt;div ng-controller=\"DoubleController\"&gt; Two times &lt;input ng-model=\"num\"&gt; equals &#123;&#123; double(num) &#125;&#125;&lt;/div&gt; 任何被赋值给scope的对象都是model属性。任何被赋值给scope的方法均可在 模板/视图 中通过 angular 表达式和 ng 事件处理指令进行调用(e.g. ngClick)。 正确使用控制器正常情况下，我们不应该让控制器做太多的事。它应该只包含单个视图的业务逻辑。 保持控制器代码简洁的通用做法是，将不属于控制器的工作封装到服务中，然后通过依赖注入的方式在控制器中使用这些服务。 连接控制器和Angular Scope对象你可以通过 ngController 指令或 $route 服务，隐式连接控制器和 scope 对象","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://joky.me/tags/AngularJS/"}]},{"title":"从零开始学习AngularJS开发(一) 概述","date":"2016-12-04T15:03:00.000Z","path":"AngularJS/AngularJS-1.html","text":"AngularJS概述 概念 描述 模板(Template) 带有附加标记的HTML 指令(Directives) 自定义属性和元素来扩展HTML 模型(Model) 显示给用户，跟用户进行交互的数据 作用域(Scope) model存放在scope中以便控制器(Controllers)，指令(Directives)和表达式(expressions)访问 表达式(Expressions) 用于访问scope中的变量和函数 编译器(Compiler) 解析模板，实例化指令和表达式 过滤器(Filter) 格式化表达式的值 视图(View) 页面(DOM) 数据绑定(Data Binding) 在模型和视图间同步数据 控制器(Controller) 视图背后的业务逻辑 依赖注入(Dependency Injector) 负责创建和装载对象和函数 注入器(Injector) 依赖注入容器 模块(Module) 用来配置注入器的容器 服务(Service) 独立于视图的可复用的业务逻辑","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://joky.me/tags/AngularJS/"}]}]